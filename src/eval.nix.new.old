{ system ? builtins.currentSystem
, optionsWithVal ? true
, configurationnix ? "/etc/nixos/configuration.nix"
, path ? "networking.hostName"
, json ? "" }:

with import <nixpkgs/lib>;

let

  emptyEval = import <nixpkgs/nixos> {
    inherit system;
  };

  # Remove invisible and internal options.
  optionsList = filter (opt: opt.visible && !opt.internal) (optionAttrSetToDocList (if optionsWithVal then evalConfig else emptyEval).options);

  # Replace functions by the string <function>
  substFunction = x:
    if builtins.isAttrs x then mapAttrs (name: substFunction) x
    else if builtins.isList x then map substFunction x
    else if builtins.isFunction x then "<function>"
    else x;

  # Clean up declaration sites to not refer to the NixOS source tree.
  optionsList_ = flip map optionsList (opt:
    let
        path = splitString "." opt.name;
        val = if optionsWithVal then (tryToGetValue path).val else null;
    in
    opt // {
      declarations = map (fn: stripPrefix fn) opt.declarations;
    }
    // optionalAttrs (opt ? example) { example = substFunction opt.example; }
    // optionalAttrs (opt ? default) { default = substFunction opt.default; }
    # // optionalAttrs (opt ? type) { type = substFunction opt.type; }
    # // optionalAttrs (opt ? type) { inherit val; });
    // optionalAttrs (opt ? type) { val = evalOptionValue_ path opt []; });

  prefix = toString <nixpkgs>;

  stripPrefix = fn:
    if substring 0 (stringLength prefix) fn == prefix then
      substring (stringLength prefix + 1) 1000 fn
    else
      fn;

  emptyPkgs = import <nixpkgs> { };
  config = (import configurationnix { pkgs = emptyPkgs; config = emptyPkgs.config; }).nixpkgs.config;
  pkgs = import <nixpkgs> { inherit config; };
  configuration = (import configurationnix { inherit pkgs; inherit (pkgs) config; });
  # eval = import <nixpkgs/nixos> {
  #   inherit system configuration;
  # };
  tryToGetValue = path:
    let
      # t = builtins.tryEval (createEntry path eval.config);
      t = builtins.tryEval (createEntry path evalConfig.config);
    in
      (if t.success then
        t.value
      else
        "<tryToGetValueError>");
  createEntry = path: root:
    let
      value = if path == [""] then root else attrByPath path null root;
      # val = substFunction value;
      val = scrubOptionValue_ path value [];
    in {
        inherit path val;
      };
  scrubOptionValue_ = path: x: visitList:
    let
      t = tryScrubOptionValue path x visitList;
    in
      (if t.success then
        t.value
      else
        "<scrubOptionValue_Error>");

  tryScrubOptionValue = path: x: visitList:
    let
      visitList_ = ([x] ++ visitList);
    in
      builtins.tryEval (
        if isNull x then "<null>"
        else if any (element: element == x) visitList then "<recursion>"
        else if isDerivation x then "<drv>"+(toString x.outPath)+"</drv>"
        else if isInt x then x
        else if isString x then x
        else if isBool x then x
        else if isFunction x then "<function>"
        else if isList x then (map (y: scrubOptionValue_ path y visitList_) x)
        else if isAttrs x then (mapAttrs (n: v: if isNull v then "<null>" else (scrubOptionValue_ path v visitList_)) x)
        else if builtins.typeOf x == "lambda" then "<lambda>"
        else toString x);

  values = tryToGetValue [""];

  evalConfig = import <nixpkgs/nixos/lib/eval-config.nix> {
    inherit system;
    # modules = [ (import configurationnix { pkgs = emptyPkgs; config = emptyPkgs.config; }) ];
    modules = (import <nixpkgs/nixos/modules/module-list.nix>) ++ [ configuration ];
    check = false;
  };

  evalOptionValue_ = loc: opt: defs:
  let
    # Add in the default value for this option, if any.
    defs_ =
        (optional (opt ? default)
          { file = head opt.declarations; value = mkOptionDefault opt.default; }) ++ defs;

    # Handle properties, check types, and merge everything together.
    res =
      if opt.readOnly or false && length defs_ > 1 then
        throw "The option `${showOption loc}' is read-only, but it's set multiple times."
      else
        mergeDefinitions loc opt.type defs_;

    # Check whether the option is defined, and apply the ‘apply’
    # function to the merged value.  This allows options to yield a
    # value computed from the definitions.
    value =
      if !res.isDefined then
        throw "The option `${showOption loc}' is used but not defined."
      else if opt ? apply then
        opt.apply res.mergedValue
      else
        res.mergedValue;

  in opt //
    { value = addErrorContext "while evaluating the option `${showOption loc}':" value;
      definitions = map (def: def.value) res.defsFinal;
      files = map (def: def.file) res.defsFinal;
      inherit (res) isDefined;
    };

in {
  test = builtins.toJSON (substFunction evalConfig.config.networking);
  options = builtins.unsafeDiscardStringContext (builtins.toJSON (listToAttrs (map (o: { name = o.name; value = removeAttrs o ["visible" "internal"]; }) optionsList_)));
  config = builtins.unsafeDiscardStringContext (builtins.toJSON (values));
  get = builtins.fromJSON (builtins.unsafeDiscardStringContext (builtins.toJSON (tryToGetValue (splitString "." path)).val));
  parse = builtins.fromJSON json;
}
